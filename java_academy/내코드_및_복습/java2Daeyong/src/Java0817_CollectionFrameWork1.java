import java.util.ArrayList;
import java.util.Iterator;

/*

오늘 내용은 구조적인 이야기가 많다. ex. a로, b로, c로 해도 상관 없는데도, 왜 a를 써야하는지, 왜 b를 쓰면 안되는지 등을 꼼꼼히 짚고 넘어가야 한다.

컬렉션 프레임워크 == 자료구조
리스트 == 배열리스트 / 연결리스트 (파이썬의 그 리스트 아니다)
배열리스트: 삽입, 삭제, 탐색 등의 메서드를 구현해놓은 자바식 배열 + 인덱싱 방식
여녈리스트 : 삽입, 삭제가 유리하다. 탐색 및 검색은 불리하다.


1. 배열: 정적이며 삽입 삭제가 매우 불리하지만, 검색과 같은 활동은 매우 유용하다.
-> 배열은 출신지가 C쪽.

2. 배열을 쓰도록 만들어놓은 컬렉션이 배열리스트이다.
-> 배열리스트는 출신지가 자바쪽. (객체지향)

3. 연결 리스트는 화살표 긋는 방식이다. 새로 하나 만들어서 화살표만 살짝 넣어주면  추가된다. 화살표 하나 스윽 넘겨주면 제거된다.
따라서 삽입, 삭제가 편하지만, 탐색 검색의 경우 직접 화살표를 따라가야 하니(인덱싱 방식 x) 불리하다.

## 배열리스트 <---> 연결리스트 라 보면 편할듯.


*/

public class Java0817_CollectionFrameWork1 {

	public static void main(String[] args) {
		int [] a1 = new int [3]; // C언어 식. a1은 변수
		ArrayList a2 = new ArrayList(3); // 생성자. a2는 객체이다. 
		// 위는 그냥 배열만들기, 아래는 객체만들기이다.
		a1[0] = 10;
		a1[1] = 20;
		a1[2] = 30;
		// a1[3] = 40; int 배열은 정적이라 스스로 늘어날 수 없다. 
		System.out.println(a1);
// #################이거 중요할듯. 배열은 정적이라 실행중에 늘렸다 줄였다 할 수 없다.###############################
// #################이거 중요할듯. arrayList는 동적이라 실행중에 늘렸다 줄였다 할 수 있다.#########################
		a2.add(100);
		a2.add(0,200); // 0번 인덱스에 200넣기
		a2.add(300); // 0번 인덱스에 200넣기
		a2.add(400); // 0번 인덱스에 200넣기
		a2.add("네네치킨"); // 배열 리스트는 타입에 무관하게 모든걸 다 저장할 수 있다.
		System.out.println(a2); // 오오 편하다!

		for (int v : a1) {
			System.out.print(++v + " ");
		}
		System.out.println();		
		
		for (int i= 0 ; i < a1.length ; i++ ) {
			System.out.print(a1[i] + " ");
		}
		System.out.println();
		
		
// for each 문의 작동 방식 -> 기존 리스트를 복사한다. 그리고 그 복사한 것에 v를 배정한다. 
// 따라서 v에 어떤 짓을 해도 기존 리스트는 그대로이다.
// 만약 모든 리스트 원소에 뭔가를 하고싶으면, for each문을 사용하면 안된다. -> 복사한 것을 보여주는 것이기 때문에
		
		for (int i = 0 ; i < a2.size(); i++) { // size()는 arrayList의 크기를 보여준다.
			// size() 때문에 배열의 길이와 배열의 크기는 혼용된다. 물론 자바 한정이다. 씨에서는 다르다.
			System.out.print(a2.get(i)+ " ");
		}
		System.out.println();
		
		
//###################################이터레이터 매우중요##################################################################
// iterator 반복자. 
// for each 가 부러워서 컬렉션 프레임워크도 나도 할래! 한게 반복자이다.
		Iterator itr = a2.iterator(); // 출신지가 이터레이터, 아웃풋 자료형이 이터레이터다.
		// ArrayList가 복사되어서 itr에 들어가게 된다. itr에 뭔짓을 해도 a2에는 영향이 없다는 것이다.
//##############중요한 함수 (itr 출신) 세개 -> hasNext() / next() / remove()########################
//############## hasNext() 뒤에꺼 있어? next() 그럼 이걸 해. ########################################
		
		while(itr.hasNext()) { // ++ 같은거 안해도 지가 알아서 간다.
			System.out.print(itr.next() + " ");
		}
		System.out.println();
		
		// 제네릭(generic)이란 것을 배운다.
		// : 자료구조가 저장할 수 있는 데이터의 타입을 일반화
		ArrayList<Integer> a3 = new ArrayList(); // int라고 쓰면 안된다. Integer이라 정확히 써야한다.
		// <>안에 class 명. <Class명>
		a3.add(100);
		// a3.add("ABC"); 제네릭이 붙은 컬렉션프레임워크는 자료형을 맞춰야 한다.
		System.out.println(a3);
		
		
		
		
	}

}
